import { useState, useEffect } from "react";
import { ref, onValue, query, limitToLast, orderByKey } from "firebase/database";
import { database } from "@/lib/firebase";
import { useAuth } from "@/hooks/useAuth";
import { useWaterLevelHistory, useWasteBinHistory } from "@/hooks/useHistoryData";
import DashboardLayout from "@/components/layout/DashboardLayout";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { 
  Tabs, 
  TabsContent, 
  TabsList, 
  TabsTrigger 
} from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { 
  LineChart, 
  Line, 
  BarChart,
  Bar,
  AreaChart,
  Area,
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  Legend, 
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell
} from "recharts";
import { CalendarIcon, InfoIcon, AlertTriangleIcon, TrendingUpIcon, TrendingDownIcon, CloudRainIcon } from "lucide-react";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Separator } from "@/components/ui/separator";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
import { WaterLevel, WasteBin, Device } from "@/types";

// Define the interface for water level history
interface WaterLevelHistory {
  timestamp: string;
  level: number;
}

// Define the interface for waste bin history
interface WasteBinHistory {
  timestamp: string;
  fullness: number;
  weight: number;
}

// Define prediction interface for predictive analytics
interface Prediction {
  timestamp: string;
  predictedLevel: number;
  confidence: number;
}

// Define trend data interface for trend analysis
interface TrendData {
  period: string;
  value: number;
  trend: 'increasing' | 'decreasing' | 'stable';
  changePct: number;
}

interface RainData {
  date: string;
  precipitation: number;
}

export default function WaterLevelDetails() {
  const { user } = useAuth();
  const [location, setLocation] = useLocation();
  const [device, setDevice] = useState<Device | null>(null);
  const [waterLevel, setWaterLevel] = useState<WaterLevel | null>(null);
  const [wasteBin, setWasteBin] = useState<WasteBin | null>(null);
  const [waterHistory, setWaterHistory] = useState<WaterLevelHistory[]>([]);
  const [binHistory, setBinHistory] = useState<WasteBinHistory[]>([]);
  const [predictions, setPredictions] = useState<Prediction[]>([]);
  const [waterTrends, setWaterTrends] = useState<TrendData[]>([]);
  const [wasteTrends, setWasteTrends] = useState<TrendData[]>([]);
  const [rainData, setRainData] = useState<RainData[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedDate, setSelectedDate] = useState<Date | undefined>(new Date());
  const [activeTab, setActiveTab] = useState<string>("overview");
  
  // Get device ID from URL path parameter
  const [, deviceId] = location.split("/water-levels/");
  
  // Use the history hooks to get real data
  const { history: waterHistoryData } = useWaterLevelHistory(deviceId);
  const { history: wasteBinHistoryData } = useWasteBinHistory(deviceId);

  useEffect(() => {
    if (!user || !deviceId) return;
    
    const deviceRef = ref(database, `users/${user.uid}/devices`);
    const deviceUnsubscribe = onValue(deviceRef, (snapshot) => {
      if (!snapshot.exists()) {
        setDevice(null);
        setLoading(false);
        return;
      }
      
      // Find device by ID
      const devices = snapshot.val();
      let foundDevice = null;
      let deviceKey = null;
      
      Object.entries(devices).forEach(([key, value]: [string, any]) => {
        if (value.id === deviceId) {
          foundDevice = { ...value, id: deviceId };
          deviceKey = key;
        }
      });
      
      if (!foundDevice) {
        setDevice(null);
        setLoading(false);
        return;
      }
      
      setDevice(foundDevice);
      
      // Get water level data
      const waterLevelRef = ref(database, `users/${user.uid}/waterLevels/${deviceKey}`);
      const waterLevelUnsubscribe = onValue(waterLevelRef, (waterLevelSnapshot) => {
        if (waterLevelSnapshot.exists()) {
          setWaterLevel(waterLevelSnapshot.val());
        } else {
          setWaterLevel(null);
        }
      });
      
      // Get waste bin data
      const wasteBinRef = ref(database, `users/${user.uid}/wasteBins/${deviceKey}`);
      const wasteBinUnsubscribe = onValue(wasteBinRef, (wasteBinSnapshot) => {
        if (wasteBinSnapshot.exists()) {
          setWasteBin(wasteBinSnapshot.val());
        } else {
          setWasteBin(null);
        }
      });
    });
    
    setLoading(false);

    return () => {
      deviceUnsubscribe();
    };
  }, [user, deviceId]);
  
  // Update water history data when it changes
  useEffect(() => {
    if (waterHistoryData && waterHistoryData.length > 0) {
      const formattedData = waterHistoryData.map(item => ({
        timestamp: item.timestamp,
        level: item.level
      }));
      setWaterHistory(formattedData);
      
      // Only generate predictions and trends if we have real data
      setPredictions(generateSamplePredictions(formattedData));
      setWaterTrends(generateSampleWaterTrends(formattedData));
      
      // Generate rain data for context (can be replaced with real data in the future)
      setRainData(generateSampleRainData());
    }
  }, [waterHistoryData]);
  
  // Update waste bin history data when it changes
  useEffect(() => {
    if (wasteBinHistoryData && wasteBinHistoryData.length > 0) {
      const formattedData = wasteBinHistoryData.map(item => ({
        timestamp: item.timestamp,
        fullness: item.fullness,
        weight: item.weight
      }));
      setBinHistory(formattedData);
      
      // Only generate trends if we have real data
      setWasteTrends(generateSampleWasteTrends(formattedData));
    }
  }, [wasteBinHistoryData]);

  function generateSamplePredictions(history: WaterLevelHistory[]): Prediction[] {
    if (!history.length) return [];
    
    const predictions: Prediction[] = [];
    const lastPoint = history[history.length - 1];
    const now = new Date(lastPoint.timestamp);
    
    // Simple linear trend-based prediction (simplified)
    // In a real app, this would use more sophisticated algorithms
    let trend = 0;
    if (history.length > 1) {
      const recentHistory = history.slice(-5);
      const avgChange = recentHistory.reduce((sum, curr, i, arr) => {
        if (i === 0) return sum;
        return sum + (curr.level - arr[i-1].level);
      }, 0) / (recentHistory.length - 1);
      
      trend = avgChange;
    }
    
    // Generate predictions for the next 5 days
    for (let i = 1; i <= 5; i++) {
      const predictionDate = new Date(now);
      predictionDate.setDate(now.getDate() + i);
      
      // Use trend to predict future values, with confidence decreasing over time
      const predictedLevel = Math.max(0, Math.min(100, lastPoint.level + (trend * i)));
      const confidence = Math.max(10, 90 - (i * 15)); // Confidence decreases over time
      
      predictions.push({
        timestamp: predictionDate.toISOString(),
        predictedLevel,
        confidence
      });
    }
    
    return predictions;
  }
  
  function generateSampleWaterTrends(history: WaterLevelHistory[]): TrendData[] {
    if (!history.length) return [];
    
    // Calculate trends for different time periods
    const now = new Date();
    const trends: TrendData[] = [];
    
    // Daily trend (last 24 hours)
    const dayStart = new Date(now);
    dayStart.setHours(now.getHours() - 24);
    const dayData = history.filter(item => new Date(item.timestamp) >= dayStart);
    
    if (dayData.length >= 2) {
      const startValue = dayData[0].level;
      const endValue = dayData[dayData.length - 1].level;
      const changePct = ((endValue - startValue) / startValue) * 100;
      const trend = changePct > 1 ? 'increasing' : (changePct < -1 ? 'decreasing' : 'stable');
      
      trends.push({
        period: "24 hours",
        value: endValue,
        trend,
        changePct
      });
    }
    
    // Weekly trend
    const weekStart = new Date(now);
    weekStart.setDate(now.getDate() - 7);
    const weekData = history.filter(item => new Date(item.timestamp) >= weekStart);
    
    if (weekData.length >= 2) {
      const startValue = weekData[0].level;
      const endValue = weekData[weekData.length - 1].level;
      const changePct = ((endValue - startValue) / startValue) * 100;
      const trend = changePct > 1 ? 'increasing' : (changePct < -1 ? 'decreasing' : 'stable');
      
      trends.push({
        period: "7 days",
        value: endValue,
        trend,
        changePct
      });
    }
    
    // Monthly trend
    const monthStart = new Date(now);
    monthStart.setDate(now.getDate() - 30);
    const monthData = history.filter(item => new Date(item.timestamp) >= monthStart);
    
    if (monthData.length >= 2) {
      const startValue = monthData[0].level;
      const endValue = monthData[monthData.length - 1].level;
      const changePct = ((endValue - startValue) / startValue) * 100;
      const trend = changePct > 1 ? 'increasing' : (changePct < -1 ? 'decreasing' : 'stable');
      
      trends.push({
        period: "30 days",
        value: endValue,
        trend,
        changePct
      });
    }
    
    return trends;
  }
  
  function generateSampleWasteTrends(history: WasteBinHistory[]): TrendData[] {
    if (!history.length) return [];
    
    // Calculate trends for different time periods
    const now = new Date();
    const trends: TrendData[] = [];
    
    // Daily trend (last 24 hours)
    const dayStart = new Date(now);
    dayStart.setHours(now.getHours() - 24);
    const dayData = history.filter(item => new Date(item.timestamp) >= dayStart);
    
    if (dayData.length >= 2) {
      const startValue = dayData[0].fullness;
      const endValue = dayData[dayData.length - 1].fullness;
      const changePct = ((endValue - startValue) / (startValue || 1)) * 100;
      const trend = changePct > 1 ? 'increasing' : (changePct < -1 ? 'decreasing' : 'stable');
      
      trends.push({
        period: "24 hours",
        value: endValue,
        trend,
        changePct
      });
    }
    
    // Weekly trend
    const weekStart = new Date(now);
    weekStart.setDate(now.getDate() - 7);
    const weekData = history.filter(item => new Date(item.timestamp) >= weekStart);
    
    if (weekData.length >= 2) {
      const startValue = weekData[0].fullness;
      const endValue = weekData[weekData.length - 1].fullness;
      const changePct = ((endValue - startValue) / (startValue || 1)) * 100;
      const trend = changePct > 1 ? 'increasing' : (changePct < -1 ? 'decreasing' : 'stable');
      
      trends.push({
        period: "7 days",
        value: endValue,
        trend,
        changePct
      });
    }
    
    // Monthly trend
    const monthStart = new Date(now);
    monthStart.setDate(now.getDate() - 30);
    const monthData = history.filter(item => new Date(item.timestamp) >= monthStart);
    
    if (monthData.length >= 2) {
      const startValue = monthData[0].fullness;
      const endValue = monthData[monthData.length - 1].fullness;
      const changePct = ((endValue - startValue) / (startValue || 1)) * 100;
      const trend = changePct > 1 ? 'increasing' : (changePct < -1 ? 'decreasing' : 'stable');
      
      trends.push({
        period: "30 days",
        value: endValue,
        trend,
        changePct
      });
    }
    
    return trends;
  }
  
  function generateSampleRainData(): RainData[] {
    const rainData: RainData[] = [];
    const now = new Date();
    
    // Past 5 days
    for (let i = 6; i >= 0; i--) {
      const date = new Date(now);
      date.setDate(now.getDate() - i);
      
      // Random precipitation data (mm)
      const precipitation = Math.random() * 15;
      
      rainData.push({
        date: date.toISOString().split('T')[0],
        precipitation: Number(precipitation.toFixed(1))
      });
    }
    
    // Future 5 days (forecast)
    for (let i = 1; i <= 5; i++) {
      const date = new Date(now);
      date.setDate(now.getDate() + i);
      
      // Random precipitation forecast (mm)
      const precipitation = Math.random() * 10;
      
      rainData.push({
        date: date.toISOString().split('T')[0],
        precipitation: Number(precipitation.toFixed(1))
      });
    }
    
    return rainData;
  }
  
  function getWaterLevelColor(level: number): string {
    if (level > 85) return "bg-red-500";
    if (level > 65) return "bg-amber-500";
    if (level > 35) return "bg-green-500";
    return "bg-blue-500";
  }
  
  function getWaterLevelTextColor(level: number): string {
    if (level > 85) return "text-red-500";
    if (level > 65) return "text-amber-500";
    if (level > 35) return "text-green-500";
    return "text-blue-500";
  }
  
  function getWaterLevelStatus(level: number): string {
    if (level > 85) return "Critical";
    if (level > 65) return "Warning";
    if (level > 35) return "Normal";
    return "Low";
  }
  
  function getStatusBackground(level: number): string {
    if (level > 85) return "bg-red-100";
    if (level > 65) return "bg-amber-100";
    if (level > 35) return "bg-green-100";
    return "bg-blue-100";
  }
  
  function getBinFullnessColor(fullness: number): string {
    if (fullness > 85) return "bg-red-500";
    if (fullness > 65) return "bg-amber-500";
    return "bg-green-500";
  }
  
  function getBinTextColor(fullness: number): string {
    if (fullness > 85) return "text-red-500";
    if (fullness > 65) return "text-amber-500";
    return "text-green-500";
  }
  
  function getBinStatus(fullness: number): string {
    if (fullness > 85) return "Full";
    if (fullness > 65) return "Warning";
    return "OK";
  }
  
  function getTrendAnalysis(): string {
    if (!waterHistory.length) return "Insufficient data";
    
    const current = waterHistory[waterHistory.length - 1].level;
    const previous = waterHistory[0].level;
    const change = current - previous;
    
    if (Math.abs(change) < 5) {
      return "Water levels have remained relatively stable over the monitored period.";
    } else if (change > 0) {
      return `Water levels have increased by approximately ${change.toFixed(1)}% over the monitored period. This could indicate increased rainfall or reduced drainage capacity.`;
    } else {
      return `Water levels have decreased by approximately ${Math.abs(change).toFixed(1)}% over the monitored period. This indicates effective drainage or reduced water input.`;
    }
  }
  
  function getRecommendations(): string[] {
    const recommendations = [];
    
    // Water level based recommendations
    if (waterLevel) {
      if (waterLevel.level > 85) {
        recommendations.push("URGENT: Water levels are critically high. Immediate inspection recommended.");
        recommendations.push("Consider emergency drainage protocols.");
      } else if (waterLevel.level > 65) {
        recommendations.push("Water levels are elevated. Schedule an inspection within 24-48 hours.");
        recommendations.push("Monitor drainage outflow for potential blockages.");
      }
    }
    
    // Waste bin based recommendations
    if (wasteBin) {
      if (wasteBin.fullness > 85) {
        recommendations.push("Waste bin is nearly full. Schedule collection immediately.");
      } else if (wasteBin.fullness > 65) {
        recommendations.push("Waste bin is filling up. Plan collection within the next 3 days.");
      }
      
      if (wasteBin.weight > 50) {
        recommendations.push("Waste weight is high. Ensure appropriate handling equipment is used during collection.");
      }
    }
    
    // Trend based recommendations
    if (waterTrends.length > 0) {
      const latestTrend = waterTrends[0];
      if (latestTrend.trend === 'increasing' && latestTrend.changePct > 10) {
        recommendations.push(`Water level is rising rapidly (${latestTrend.changePct.toFixed(1)}% in ${latestTrend.period}). Investigate potential inflow issues.`);
      }
    }
    
    if (recommendations.length === 0) {
      recommendations.push("All systems operating within normal parameters. No immediate action required.");
      recommendations.push("Continue regular maintenance schedule.");
    }
    
    return recommendations;
  }
  
  if (loading) {
    return (
      <DashboardLayout title="Loading..." subtitle="Please wait">
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
        </div>
      </DashboardLayout>
    );
  }
  
  if (!device) {
    return (
      <DashboardLayout title="Device Not Found" subtitle="The requested device could not be found">
        <div className="flex flex-col items-center justify-center h-64 space-y-4">
          <AlertTriangleIcon className="w-16 h-16 text-amber-500" />
          <h2 className="text-xl font-semibold">Device Not Found</h2>
          <p className="text-gray-500">The water level device you're looking for could not be found.</p>
          <Button onClick={() => setLocation("/water-levels")}>Return to Water Levels</Button>
        </div>
      </DashboardLayout>
    );
  }
  
  return (
    <DashboardLayout 
      title={device.name || "Water Level Details"} 
      subtitle={device.location || "Location not specified"}
    >
      {/* Quick Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        {/* Water Level Card */}
        <Card className="relative overflow-hidden">
          <CardHeader className="pb-2">
            <CardTitle className="text-lg font-medium">Current Water Level</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center justify-between">
              <div>
                <div className="text-3xl font-bold">
                  {waterLevel ? `${waterLevel.level}%` : "N/A"}
                </div>
                <div className="text-sm text-gray-500">
                  Last updated: {waterLevel ? waterLevel.lastUpdated : "Never"}
                </div>
              </div>
              <div className="w-16 h-16 rounded-full flex items-center justify-center">
                <div 
                  className={`w-full h-full rounded-full flex items-center justify-center ${waterLevel ? getStatusBackground(waterLevel.level) : "bg-gray-100"}`}
                >
                  <div 
                    className={`text-sm font-medium ${waterLevel ? getWaterLevelTextColor(waterLevel.level) : "text-gray-400"}`}
                  >
                    {waterLevel ? getWaterLevelStatus(waterLevel.level) : "No data"}
                  </div>
                </div>
              </div>
            </div>
            
            {/* Water level visualization */}
            <div className="mt-4 h-6 bg-gray-200 rounded-full overflow-hidden">
              <div 
                className={`h-full ${waterLevel ? getWaterLevelColor(waterLevel.level) : "bg-gray-400"}`}
                style={{ width: `${waterLevel ? waterLevel.level : 0}%` }}
              ></div>
            </div>
          </CardContent>
        </Card>
        
        {/* Waste Bin Card */}
        <Card className="relative overflow-hidden">
          <CardHeader className="pb-2">
            <CardTitle className="text-lg font-medium">Waste Bin Status</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center justify-between">
              <div>
                <div className="text-3xl font-bold">
                  {wasteBin ? `${wasteBin.fullness}%` : "N/A"}
                </div>
                <div className="text-sm text-gray-500">
                  Last emptied: {wasteBin ? wasteBin.lastEmptied : "Never"}
                </div>
              </div>
              <div className="w-16 h-16 rounded-full flex items-center justify-center">
                <div 
                  className={`w-full h-full rounded-full flex items-center justify-center ${wasteBin ? (wasteBin.fullness > 85 ? "bg-red-100" : wasteBin.fullness > 65 ? "bg-amber-100" : "bg-green-100") : "bg-gray-100"}`}
                >
                  <div 
                    className={`text-sm font-medium ${wasteBin ? getBinTextColor(wasteBin.fullness) : "text-gray-400"}`}
                  >
                    {wasteBin ? getBinStatus(wasteBin.fullness) : "No data"}
                  </div>
                </div>
              </div>
            </div>
            
            {/* Fullness visualization */}
            <div className="mt-4 h-6 bg-gray-200 rounded-full overflow-hidden">
              <div 
                className={`h-full ${wasteBin ? getBinFullnessColor(wasteBin.fullness) : "bg-gray-400"}`}
                style={{ width: `${wasteBin ? wasteBin.fullness : 0}%` }}
              ></div>
            </div>
          </CardContent>
        </Card>
        
        {/* Waste Weight Card */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-lg font-medium">Waste Weight</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center justify-between">
              <div>
                <div className="text-3xl font-bold">
                  {wasteBin ? `${wasteBin.weight.toFixed(1)} kg` : "N/A"}
                </div>
                <div className="text-sm text-gray-500">
                  Measured capacity: 100 kg
                </div>
              </div>
              <div className="w-16 h-16">
                <svg className="w-full h-full" viewBox="0 0 24 24" fill="none">
                  <path d="M12 3L4 10H20L12 3Z" fill="#94A3B8" />
                  <rect x="5" y="10" width="14" height="2" fill="#94A3B8" />
                  <rect x="6" y="12" width="12" height="8" fill="#94A3B8" />
                  <rect x="8" y="20" width="8" height="1" fill="#94A3B8" />
                </svg>
              </div>
            </div>
            
            {/* Weight visualization */}
            <div className="mt-4 h-6 bg-gray-200 rounded-full overflow-hidden">
              <div 
                className="h-full bg-indigo-500"
                style={{ width: `${wasteBin ? Math.min(100, (wasteBin.weight / 100) * 100) : 0}%` }}
              ></div>
            </div>
          </CardContent>
        </Card>
      </div>
      
      {/* Tabs for different views */}
      <Tabs defaultValue="overview" value={activeTab} className="w-full mb-6">
        <TabsList className="grid w-full grid-cols-2 md:grid-cols-4 mb-6">
          <TabsTrigger value="overview" onClick={() => setActiveTab("overview")}>Overview</TabsTrigger>
          <TabsTrigger value="water-history" onClick={() => setActiveTab("water-history")}>Water Level History</TabsTrigger>
          <TabsTrigger value="waste-history" onClick={() => setActiveTab("waste-history")}>Waste Bin History</TabsTrigger>
          <TabsTrigger value="analytics" onClick={() => setActiveTab("analytics")}>Analytics</TabsTrigger>
        </TabsList>
        
        {/* Overview Tab */}
        <TabsContent value="overview" className="space-y-6">
          {/* Chart Card */}
          <Card>
            <CardHeader>
              <CardTitle>Combined Sensor Readings</CardTitle>
              <CardDescription>Last 7 days of data</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="h-80">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart
                    data={waterHistory.map((item, index) => ({
                      date: new Date(item.timestamp).toLocaleDateString(),
                      waterLevel: item.level,
                      binFullness: binHistory[index]?.fullness || 0,
                      binWeight: binHistory[index]?.weight || 0,
                    }))}
                    margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="date" />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    <Line 
                      type="monotone" 
                      dataKey="waterLevel" 
                      name="Water Level (%)"
                      stroke="#2563eb" 
                      activeDot={{ r: 8 }} 
                    />
                    <Line 
                      type="monotone" 
                      dataKey="binFullness" 
                      name="Bin Fullness (%)"
                      stroke="#16a34a" 
                    />
                    <Line 
                      type="monotone" 
                      dataKey="binWeight" 
                      name="Bin Weight (kg)"
                      stroke="#7c3aed" 
                    />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </CardContent>
          </Card>
          
          {/* Trends and Insights */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {/* Average Water Level */}
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Average Water Level</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex flex-col items-center justify-center h-28">
                  <div className="text-lg font-bold">{waterHistory.length > 0 ? Math.round(waterHistory.reduce((acc, item) => acc + item.level, 0) / waterHistory.length) : 0}%</div>
                </div>
              </CardContent>
            </Card>
            
            {/* Average Bin Fullness */}
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Average Bin Fullness</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex flex-col items-center justify-center h-28">
                  <div className="text-lg font-bold">{binHistory.length > 0 ? Math.round(binHistory.reduce((acc, item) => acc + item.fullness, 0) / binHistory.length) : 0}%</div>
                </div>
              </CardContent>
            </Card>
            
            {/* Device Status */}
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Device Status</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="flex flex-col items-center justify-center h-28">
                  <Badge variant={device.status === "active" ? "default" : "outline"}>
                    {device.status === "active" ? "Active" : "Inactive"}
                  </Badge>
                  <div className="text-xs text-gray-500 mt-2">
                    Last seen: {device.lastSeen}
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </TabsContent>
        
        {/* Water Level History Tab */}
        <TabsContent value="water-history">
          <Card>
            <CardHeader>
              <CardTitle className="text-base font-medium">Water Level History</CardTitle>
              <CardDescription>Detailed history of water level readings</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="h-80 mb-6">
                <ResponsiveContainer width="100%" height="100%">
                  <AreaChart
                    data={waterHistory.map(item => ({
                      date: new Date(item.timestamp).toLocaleDateString(),
                      level: item.level
                    }))}
                    margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="date" />
                    <YAxis />
                    <Tooltip />
                    <Area 
                      type="monotone" 
                      dataKey="level" 
                      name="Water Level (%)"
                      stroke="#2563eb" 
                      fill="#93c5fd" 
                    />
                  </AreaChart>
                </ResponsiveContainer>
              </div>
              
              <div className="space-y-4">
                <h3 className="font-medium text-base">Critical Events</h3>
                {waterHistory.filter(item => item.level > 85).length > 0 ? (
                  waterHistory
                    .filter(item => item.level > 85)
                    .map((item, index) => (
                      <div key={index} className="p-3 bg-red-50 border border-red-200 rounded-md">
                        <div className="flex items-center">
                          <AlertTriangleIcon className="w-5 h-5 text-red-500 mr-2" />
                          <div>
                            <div className="font-medium">Critical Water Level</div>
                            <div className="text-sm text-gray-500">
                              {new Date(item.timestamp).toLocaleString()}: {item.level}%
                            </div>
                          </div>
                        </div>
                      </div>
                    ))
                ) : (
                  <div className="p-3 bg-green-50 border border-green-200 rounded-md">
                    <div className="flex items-center">
                      <div className="w-5 h-5 bg-green-500 rounded-full mr-2"></div>
                      <div>
                        <div className="font-medium">No Critical Events</div>
                        <div className="text-sm text-gray-500">
                          Water levels have remained below critical thresholds
                        </div>
                      </div>
                    </div>
                  </div>
                )}
                
                <h3 className="font-medium text-base mt-6">Water Level Statistics</h3>
                <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                  <div className="p-4 bg-gray-50 rounded-md">
                    <div className="text-sm text-gray-500">Average</div>
                    <div className="text-xl font-semibold">
                      {waterHistory.length > 0 ? Math.round(waterHistory.reduce((acc, item) => acc + item.level, 0) / waterHistory.length) : 0}%
                    </div>
                  </div>
                  <div className="p-4 bg-gray-50 rounded-md">
                    <div className="text-sm text-gray-500">Maximum</div>
                    <div className="text-xl font-semibold">
                      {waterHistory.length > 0 ? Math.max(...waterHistory.map(item => item.level)) : 0}%
                    </div>
                  </div>
                  <div className="p-4 bg-gray-50 rounded-md">
                    <div className="text-sm text-gray-500">Minimum</div>
                    <div className="text-xl font-semibold">
                      {waterHistory.length > 0 ? Math.min(...waterHistory.map(item => item.level)) : 0}%
                    </div>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
        
        {/* Waste Bin History Tab */}
        <TabsContent value="waste-history">
          <Card>
            <CardHeader>
              <CardTitle className="text-base font-medium">Waste Bin History</CardTitle>
              <CardDescription>Detailed history of waste bin measurements</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="h-80 mb-6">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart
                    data={binHistory.map(item => ({
                      date: new Date(item.timestamp).toLocaleDateString(),
                      fullness: item.fullness,
                      weight: item.weight
                    }))}
                    margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="date" />
                    <YAxis yAxisId="left" orientation="left" stroke="#16a34a" />
                    <YAxis yAxisId="right" orientation="right" stroke="#7c3aed" />
                    <Tooltip />
                    <Legend />
                    <Bar 
                      yAxisId="left" 
                      dataKey="fullness" 
                      name="Bin Fullness (%)" 
                      fill="#16a34a" 
                    />
                    <Bar 
                      yAxisId="right" 
                      dataKey="weight" 
                      name="Weight (kg)" 
                      fill="#7c3aed" 
                    />
                  </BarChart>
                </ResponsiveContainer>
              </div>
              
              <div className="space-y-4">
                <h3 className="font-medium text-base">Bin Emptying History</h3>
                <div className="p-3 bg-gray-50 border border-gray-200 rounded-md">
                  <div className="text-sm text-gray-700">
                    Last emptied: {wasteBin ? wasteBin.lastEmptied : "Never"}
                  </div>
                </div>
                
                <h3 className="font-medium text-base mt-6">Bin Statistics</h3>
                <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                  <div className="p-4 bg-gray-50 rounded-md">
                    <div className="text-sm text-gray-500">Average Fullness</div>
                    <div className="text-xl font-semibold">
                      {binHistory.length > 0 ? Math.round(binHistory.reduce((acc, item) => acc + item.fullness, 0) / binHistory.length) : 0}%
                    </div>
                  </div>
                  <div className="p-4 bg-gray-50 rounded-md">
                    <div className="text-sm text-gray-500">Average Weight</div>
                    <div className="text-xl font-semibold">
                      {binHistory.length > 0 ? (binHistory.reduce((acc, item) => acc + item.weight, 0) / binHistory.length).toFixed(1) : 0} kg
                    </div>
                  </div>
                  <div className="p-4 bg-gray-50 rounded-md">
                    <div className="text-sm text-gray-500">Current Status</div>
                    <div className="text-xl font-semibold">
                      {wasteBin ? getBinStatus(wasteBin.fullness) : "Unknown"}
                    </div>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
        
        {/* Analytics Tab */}
        <TabsContent value="analytics">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Predictions Card */}
            <Card>
              <CardHeader>
                <CardTitle className="text-base font-medium">Water Level Predictions</CardTitle>
                <CardDescription>5-day forecast based on historical patterns</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="h-64 mb-4">
                  <ResponsiveContainer width="100%" height="100%">
                    <LineChart
                      data={predictions.map(item => ({
                        date: new Date(item.timestamp).toLocaleDateString(),
                        level: item.predictedLevel,
                        confidence: item.confidence
                      }))}
                      margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="date" />
                      <YAxis />
                      <Tooltip />
                      <Legend />
                      <Line 
                        type="monotone" 
                        dataKey="level" 
                        name="Predicted Level (%)"
                        stroke="#0ea5e9" 
                        strokeWidth={2}
                      />
                    </LineChart>
                  </ResponsiveContainer>
                </div>
                
                <div className="text-sm text-gray-500 mb-4">
                  <InfoIcon className="w-4 h-4 inline-block mr-1" />
                  Predictions are based on historical patterns and may not account for unexpected events.
                </div>
                
                <div className="space-y-2">
                  {predictions.map((pred, index) => (
                    <div key={index} className="flex items-center justify-between p-2 bg-blue-50 rounded">
                      <div>{new Date(pred.timestamp).toLocaleDateString()}</div>
                      <div className="font-medium">{pred.predictedLevel.toFixed(1)}%</div>
                      <div className="text-sm text-gray-500">{pred.confidence}% confidence</div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
            
            {/* Trend Analysis Card */}
            <Card>
              <CardHeader>
                <CardTitle className="text-base font-medium">Trend Analysis</CardTitle>
                <CardDescription>Water level and waste bin trends</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  {/* Water Level Trends */}
                  <h3 className="font-medium">Water Level Trends</h3>
                  <div className="space-y-2">
                    {waterTrends.map((trend, index) => (
                      <div key={index} className="flex items-center justify-between p-3 bg-blue-50 rounded-md">
                        <div className="font-medium">{trend.period}</div>
                        <div className="flex items-center">
                          {trend.trend === 'increasing' ? (
                            <TrendingUpIcon className="w-5 h-5 text-red-500 mr-1" />
                          ) : trend.trend === 'decreasing' ? (
                            <TrendingDownIcon className="w-5 h-5 text-green-500 mr-1" />
                          ) : (
                            <div className="w-5 h-5 flex items-center justify-center mr-1">—</div>
                          )}
                          <span className={
                            trend.trend === 'increasing' 
                              ? 'text-red-500' 
                              : trend.trend === 'decreasing' 
                                ? 'text-green-500' 
                                : 'text-gray-500'
                          }>
                            {trend.changePct > 0 ? '+' : ''}{trend.changePct.toFixed(1)}%
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>
                  
                  {/* Waste Bin Trends */}
                  <h3 className="font-medium mt-6">Waste Bin Trends</h3>
                  <div className="space-y-2">
                    {wasteTrends.map((trend, index) => (
                      <div key={index} className="flex items-center justify-between p-3 bg-green-50 rounded-md">
                        <div className="font-medium">{trend.period}</div>
                        <div className="flex items-center">
                          {trend.trend === 'increasing' ? (
                            <TrendingUpIcon className="w-5 h-5 text-red-500 mr-1" />
                          ) : trend.trend === 'decreasing' ? (
                            <TrendingDownIcon className="w-5 h-5 text-green-500 mr-1" />
                          ) : (
                            <div className="w-5 h-5 flex items-center justify-center mr-1">—</div>
                          )}
                          <span className={
                            trend.trend === 'increasing' 
                              ? 'text-red-500' 
                              : trend.trend === 'decreasing' 
                                ? 'text-green-500' 
                                : 'text-gray-500'
                          }>
                            {trend.changePct > 0 ? '+' : ''}{trend.changePct.toFixed(1)}%
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>
                  
                  {/* Rainfall Data */}
                  <h3 className="font-medium mt-6">Recent & Forecasted Rainfall</h3>
                  <div className="h-32">
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart
                        data={rainData}
                        margin={{ top: 5, right: 0, left: 0, bottom: 5 }}
                      >
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="date" />
                        <YAxis />
                        <Tooltip />
                        <Bar 
                          dataKey="precipitation" 
                          name="Rainfall (mm)" 
                          fill="#60a5fa" 
                        />
                      </BarChart>
                    </ResponsiveContainer>
                  </div>
                  <div className="flex items-center text-sm text-gray-500">
                    <CloudRainIcon className="w-4 h-4 mr-1" />
                    Precipitation data can help explain water level changes
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
          
          {/* Analysis and Recommendations Card */}
          <Card className="mt-6">
            <CardHeader>
              <CardTitle className="text-base font-medium">Insights & Recommendations</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-6">
                {/* Trend Analysis */}
                <div>
                  <h3 className="font-medium mb-2">Trend Analysis</h3>
                  <div className="p-4 bg-blue-50 rounded-md text-gray-700">
                    {getTrendAnalysis()}
                  </div>
                </div>
                
                {/* Recommendations */}
                <div>
                  <h3 className="font-medium mb-2">Recommendations</h3>
                  <div className="space-y-2">
                    {getRecommendations().map((rec, index) => (
                      <div key={index} className="p-3 bg-gray-50 border border-gray-200 rounded-md">
                        {rec}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
      
      {/* Action Button Group */}
      <div className="flex flex-wrap gap-2 mt-6">
        <Button 
          variant="outline"
          className="flex items-center"
          onClick={() => setLocation("/devices")}
        >
          Manage Device
        </Button>
        <Button 
          variant="outline"
          className="flex items-center"
          onClick={() => setLocation("/device-history/" + deviceId)}
        >
          View Device History
        </Button>
        <Button
          className="flex items-center ml-auto"
          onClick={() => setLocation("/water-levels")}
        >
          Back to Water Levels
        </Button>
      </div>
    </DashboardLayout>
  );
}